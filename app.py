# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CLytArr5rY6w-SxjV6DNUtB12JU9FMRr
"""

import streamlit as st
from streamlit_drawable_canvas import st_canvas
import numpy as np
import pickle
from PIL import Image

# Re-define the GaussianNaiveBayes class to load the model
# IMPORTANT: This class definition MUST exactly match the one in your Colab
# that produced the 0.5452 accuracy (i.e., before we tried adding explicit class_priors to the class attributes).
class GaussianNaiveBayes:
    def fit(self, X, y):
        # This fit method will not be called when loading, but is here for completeness.
        # The parameters are loaded directly.
        pass

    # Ensure this method is identical to the one in Colab that was used for training
    def _calculate_likelihood(self, x, mean, variance):
        exponent = -((x - mean)**2) / (2 * variance)
        likelihood = (1 / np.sqrt(2 * np.pi * variance)) * np.exp(exponent)
        return likelihood

    def predict(self, X):
        predictions = [self._predict_single_sample(x) for x in X]
        return np.array(predictions)

    # Ensure this method matches the ORIGINAL Colab version that assumed equal priors
    def _predict_single_sample(self, x):
        posteriors = []

        # Make sure self.classes and self.parameters are loaded correctly
        if not hasattr(self, 'parameters') or not hasattr(self, 'classes'):
             st.error("Model parameters or classes not loaded correctly.")
             return None # Handle error appropriately

        for c in self.classes:
            # P(class) - We assume equal prior probability, matching the original training
            prior = 1.0 / len(self.classes)

            # P(x_i | class) for each feature
            mean = self.parameters[c]['mean']
            variance = self.parameters[c]['variance']

            # Calculate likelihood for all features for this class
            # Using log-likelihood to avoid underflow with many small probabilities
            likelihoods = self._calculate_likelihood(x, mean, variance)

            # Sum of log-likelihoods + log(prior)
            # Add a small value to likelihoods to prevent log(0)
            posterior = np.sum(np.log(likelihoods + 1e-9)) + np.log(prior) # Add epsilon to avoid log(0)

            posteriors.append((posterior, c))

        # Return the class with the highest posterior probability
        return max(posteriors)[1]

# --- Load the Trained Model ---
@st.cache_resource # Cache the model loading for efficiency
def load_model(model_path):
    with open(model_path, 'rb') as file:
        parameters = pickle.load(file)
        classes = pickle.load(file)
        # Note: We are NOT loading class_priors explicitly as they were not saved
        # in the .pkl file that produced 0.5452 accuracy.

        nb_model = GaussianNaiveBayes()
        nb_model.parameters = parameters
        nb_model.classes = classes
        # class_priors are NOT an attribute for this version, as the _predict_single_sample
        # function calculates prior on the fly using 1.0 / len(self.classes)

        return nb_model

model_path = 'naive_bayes_mnist_model.pkl'

# Check if model file exists
try:
    nb_classifier = load_model(model_path)
    st.success("Model loaded successfully!")
except FileNotFoundError:
    st.error(f"Error: Model file '{model_path}' not found. Please ensure it's in the same directory as app.py.")
    st.stop() # Stop execution if model not found
except Exception as e:
    st.error(f"Error loading model: {e}")
    st.stop()

# --- Streamlit App Layout ---
st.set_page_config(layout="centered", page_title="MNIST Digit Classifier (Naive Bayes)", page_icon="✍️")

st.title("✍️ MNIST Digit Classifier")
st.markdown("Draw a digit (0-9) in the canvas below, and our Naive Bayes model will try to predict it!")

# Canvas configuration
canvas_result = st_canvas(
    fill_color="rgb(0, 0, 0)",  # Black background
    stroke_width=15,            # Thicker strokes
    stroke_color="rgb(255, 255, 255)", # White strokes
    background_color="rgb(0, 0, 0)",
    background_image=None,
    update_streamlit=True,
    height=150,
    width=150,
    drawing_mode="freedraw",
    key="canvas",
)

# --- Prediction Logic ---
if canvas_result.image_data is not None:
    # Convert RGBA to RGB (optional, but good practice if background is RGB)
    # The canvas_result.image_data is RGBA (H, W, 4)
    # Convert to PIL Image first
    img = Image.fromarray(canvas_result.image_data.astype('uint8'))

    # Convert to grayscale
    img_gray = img.convert('L')

    # Resize to 28x28 pixels
    img_resized = img_gray.resize((28, 28))

    # Invert colors (MNIST digits are white on black background)
    # Get pixel data and convert to numpy array
    img_array = np.array(img_resized)
    img_array = 255 - img_array # Invert colors: white becomes black (0), black becomes white (255)

    # Flatten the image array (28x28 to 784)
    img_flattened = img_array.flatten()

    # Scale pixel values to 0-1 (same as training data)
    input_data = img_flattened / 255.0

    # Ensure input data has correct shape for prediction (1 sample, 784 features)
    input_data = input_data.reshape(1, -1)

    if st.button("Predict Digit"):
        # Check if canvas is empty (all black after invert)
        # Sum of pixel values should be > 0 if something is drawn
        if np.sum(input_data) < 10: # A small threshold to account for minor noise or very faint marks
            st.warning("Please draw a digit on the canvas before predicting!")
        else:
            try:
                prediction = nb_classifier.predict(input_data)
                st.success(f"Predicted Digit: **{prediction[0]}**")

                # Display the processed image for debugging/visualization
                st.image(img_resized, caption="Processed Input (28x28)", width=100)
            except Exception as e:
                st.error(f"An error occurred during prediction: {e}")
                st.warning("Please try drawing again or check the model file.")

st.markdown("---")
st.markdown("### How it works:")
st.markdown("1. Draw a digit on the black canvas using white strokes.")
st.markdown("2. Click 'Predict Digit'.")
st.markdown("3. The image is resized to 28x28, converted to grayscale, inverted, and fed to a Naive Bayes model.")
st.caption("Developed by Sreelakshmi R V")